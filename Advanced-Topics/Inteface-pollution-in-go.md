
# Go中的接口污染 

如果说Go中只有一个强大的语言特性的话，那它一定是接口。Go的内部包含了来自各种类型系统的有用想法的各种组合，并且不可避免地会引起人们的好奇心。我最近调研了Github上的Go接口声明，结果表明Go用户使用了一些事实上没必要使用的接口从而导致污染了整个环境。

在必要之前，请勿导出任何接口。

接口非常好，但是接口污染却不是这样。你可能会是从在编译期间就生成静态调度表（static dispatch table)的语言（如果不是动态语言的话）转到Go，编译器会要求你显式地告知编译器某个类型要实现的接口。这就是编译器如何知道使用指向所有可用的虚函数的指针来生成*vtable*。如果你有C++或者Java的编程背景，你可能会在使用抽象类型初始化代码库是有些包袱，并作为后续练习在具体实现上的工作。这不是你应该在Go中做的。介绍具体的类型，不要导出任何接口，除非你必须鼓励外部的包实现一个接口。*io* 包是一个学习接口某些最佳实践比较好的例子。它导出了一些接口，因为它还需要导出像 *Copy* 这样的通用函数。

```go
func Copy(dst Writer, src Reader) (written int64, err error)
```

你的包应该导出通用的函数吗？如果答案是“也许会”，那么你可能会因为接口声明而污染你的包。证明多重实现的必要性是合理的，它们可能与你的包进行交互并采取相应的动作。

Go并没有一个传统意义上的调度表，并且只能在方法调度时依赖于接口值。从字面上看，它实际上更像是一种自由式的调度机制，需要在接口值赋值期间进行一些工作 -- 它为它指向的具体类型生成一个很小的查找哈希表。这项任务并不是非常昂贵的，所以这是一个公平的交换，是一个更令人愉快的类型系统。*Lan Lance Taylor* 有一篇[很棒的关于内部接口的博客文章](http://www.airs.com/blog/archives/277)，如果你想进一步了解的话。

如果用户需要某种程度的“控制反转”，那么在他们自己的作用域内一个动态接口的定义就能完成他们的工作了。这种可能性最小化了你必须对包的使用方式以及你必须处理的初始化抽象做出的假设。

同时，它也适用于可测试性的问题，你不必提供接口来帮助用户编写自己的端点（stubs）代码。今天早些时候，我收到一个请求，要从*pubsub*包中导出一个接口，以使得它更加容易被模仿（mock)。与其这样做，更合适的方式是告诉用户引入一个接口，该接口只关注他们想要为之编写端点的调用，通过接口值指向的实际实现。

```go
type acknowledger interface {
    Ack(sub string, id ...string) error
}

type mockClient struct{}

func (c *mockClient) Ack(sub string, id ...string) error {
    return nil
}

var acker acknowledger = pubsub.New(...)

acker = &mockClient{} // in the test package
```

值得注意的是，在Go中，标准库定义了一些你不费吹灰之力就能实现的微小的接口，并且在鼓励开发人员编写与标准库其余部分（以及其他第三方包）兼容的代码的方面做得很好。在可能地情况下采用标准库中可用的内容，并编写相应的文档。

每当我深刻地重新评估我对接口的理解时，Go都让我着迷。考虑到接口的最小化碎片性，这就是编程语言如何使软件不被设计成协同工作的方式。

如果你有任何建议或者意见，请ping [@rakyII](https://twitter.com/rakyll).