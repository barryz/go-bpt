> 译自：[Scheduling In Go - Part II](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html) :book:

# 介绍

在调度系列文章的第一部分中，我解释了操作系统调度器的各个方面，我认为这些方面对于理解Go调度器的语义非常重要。在这篇文章中，我将在语义层面解释Go的调度器的工作原理并关注它的高级行为。Go调度器是一个复杂的系统，它的一些小的实现细节并不重要。重要的是拥有良好的工作和行为方式。这将能够使你做出更好的工程决策。

## 开始一个项目

当你的Go程序开始时，它为主机上标记的每个虚拟核心提供了一个逻辑处理器(__P__)。如果你的处理器的每个核心有多个硬件线程（[超线程](https://en.wikipedia.org/wiki/Hyper-threading))，每个硬件线程都会被Go程序当作是一个虚拟的核心。为了更好地理解这点，请看下我的MacBook Pro的系统报告。

#### 插图1

![](https://www.ardanlabs.com/images/goinggo/94_figure1.png)

可以看到，我有一个拥有4个物理核心的处理器。这个硬件报告并没有公开每个物理核心上的硬件线程数。事实上，英特尔酷睿i7处理器具有超线程功能，这意味着每个物理内核有2个硬件线程。这将向Go程序报告有8个虚拟核可用于并行执行OS线程。

想要测试它，试试下面的程序：

#### 清单1

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {

    // NumCPU returns the number of logical
    // CPUs usable by the current process.
    fmt.Println(runtime.NumCPU())
}
```

当我在我的机器上运行这个程序时，函数`NumCPU()`返回的结果是8。任何在我机器上运行的Go程序，操作系统都将为其分配8个**P**(processor)。

每个**P**都分配给了一个操作系统线程("M")。“M”代表了机器。这个线程仍然由操作系统管理，并且操作系统仍需负责将该线程放到核心上以便执行，正如[上篇博客](https://github.com/barryz/go101-trans/blob/master/Advanced-Topics/Scheduling_In_Go-Part_1.md)解释的那样。这意味着如果我在我的机器运行Go程序，我将拥有8个可用线程来执行我的工作，每个线程都会附加到一个**P**上。

每个Go程序同事也会给定一个初始的Goroutine（”G“），这是该Go程序的执行路径。一个**G**本质上是一个[协程](https://en.wikipedia.org/wiki/Coroutine)，但是在Go里，它就叫Goroutine，所以我们将字母“C”替换成了“G”，然后我们就得到了Goroutine这个单词。你可以认为Goroutine是应用级别的线程，并且它们和操作系统的线程在很多方面很类似。正如操作系统需要在核心上进行上下文切换，Goroutines则需要在**M**上进行上下文切换。

最后一个难题是运行队列。Go调度器中有两个不同的运行队列：全局运行队列（GRQ）和本地运行队列（LRQ）。每个**P**都有一个LRQ，用于管理在该**P**的上下文环境中执行的**Gs**。这些**Gs**轮流打开和关闭分配给**P**的**M**的上下文。GRQ用于那些还未分配给**P**的**Gs**。有一个程序会将**Gs**从GRQ移动到LRQ，这点我们将在后面介绍。

插图2集中展示这些组件是如何在一起工作的。

#### 插图2

![](https://www.ardanlabs.com/images/goinggo/94_figure2.png)

## 协作调度器

正如我们在博客的第一部分讨论的，操作系统的调度器是一个抢占式的调度器。从本质上讲，这意味着你无法预测调度器在任何给定的时间将要执行哪个操作。内核在这时候将会作出决策，并且一切都是不确定的。运行在操作系统顶层的应用程序无法控制内核中发生的事情，除非它们利用[原子](https://en.wikipedia.org/wiki/Linearizability)指令和[互斥](https://en.wikipedia.org/wiki/Lock_(computer_science))调用之类的同步原语。

Go调度器是Go运行时的一部分，并且Go运行时已经内置在你的应用程序中。这意味着Go调度器运行在[用户K空间](https://en.wikipedia.org/wiki/User_space)，在内核之上。目前Go的调度器的实现不是抢占式的，它实际上是[协作式](https://en.wikipedia.org/wiki/Cooperative_multitasking)的调度器。作为协作调度器意味着**调度器需要明确在代码中的安全点处发生的用户事件以做出相关的调度决策。**

Go协作调度器最大的优点在于：它看起来或者说感觉上像是抢占式调度器。你无法预测Go调度器将要执行的操作。这是因为这个协作式的调度程序的决策不是由开发人员控制的，而是在运行时由Go自己控制。将Go调度器视为抢占式的非常重要，并且由于调度器是不确定性的，因此这并不是一件容易的事。

## Goroutine状态

和线程一样，Goroutines也有三种高级别的状态。这些状态决定了Go调度器在任何给定的**G**中所起的作用。 **G** 可以处于以下三种状态之一：等待中，可运行和执行中。

__等待中__：这意味着**G**已经停止并且在等待某件事情继续下去。（等待的）原因可能是等待操作系统（系统调用）或者同步调用（原子和互斥操作）。这些类型的[延迟](https://en.wikipedia.org/wiki/Latency_(engineering))是造成性能不佳的根本原因。

__可运行__：这意味着**G**在**M**上需要时间，用以执行其指定的指令。如果你有大量的**Gs**需要时间，那么这些**Gs**可能需要等待更长的时间才能获取到时间。此外，随着更多**Gs**争夺时间，任何给定的**G**获得的自身的时间就缩短了。这种调度器的延迟也是造成性能不佳的原因。

__执行中__：这意味着**G**已经在**M**上，并且已经在执行它的指令。与应用程序相关的工作即将完成。这是每个人都希望看到的。

## 上下文切换

Go调度器需要明确定义的用户空间的事件，这些事件发生在代码中的安全点以进行上下文切换。这些事件和安全点在函数调用中表现出来。函数调用对于Go调度器的状态来说至关重要。今天（Go1.11或更低版本），如果你运行一个没有任何函数调用的紧密循环 __(tight loops: a loop which contains few instructions and iterates many times.)__，你将因为调度器的垃圾回收导致延迟。函数调用在合理的时间范围内发生是至关重要的。

注意：有一个Go1.12的[提议](https://github.com/golang/go/issues/24543)已经被接受: 那就是，在Go调度器中应用非协作抢占技术，以允许抢占紧密循环。

在Go程序中，只要发生了以下4类事件将会使Go调度器就会做出调度决策。这并不意味着它总会发生在其中一个事件上。这意味着调度器获得了一个做决策的机会。

- 使用关键字`go`
- 垃圾回收
- 系统调用
- 同步和编排

### 使用关键字`go`

关键字`go`用来创建**G**。一旦创建了一个新的**G**，它将会给调度器一个机会用来做出调度决策。

### 垃圾回收
因为GC使用它们自己的**G**运行，这些**Gs**需要在**M**上获得时间来运行。这就导致了GC创建了大量的混乱的调度。但是，调度器非常聪明， 它了解**G**正在做什么，因此它会做出明智的决策。一个明智的决策是在切换一个**G**G时，它(调度器)希望在GC期间接触那些它们不接触堆的堆。当GC运行时，将会做出大量的调度决策。

### 系统调用

如果一个**G**产生了一个系统调用，那么该**G**将会阻塞M，有时，调度器能够将**G**从**M**上切换出去，并将新的**G**切换到相同的**M**. 但是，有时也需要一个新的M来继续执行在**P**中排队的**Gs**。我们将在下节解释这步是如何实现的。

### 同步和编排

如果一个原子，互斥，或者一个通道操作导致了一个**G**阻塞，那么调度器将会切换一个新的**G**来运行。一旦这个**G**能够再次运行，它可以重新排队并最终在**M**上进行上下文切换。

## 异步系统调用

如果你运行的操作系统有异步处理系统调用的能力，称为[网络轮询器(network poller)](https://golang.org/src/runtime/netpoll.go)的东西可用于更有效地处理系统调用。这种技术已经通过kqueue(MacOS)， epoll(Linux)或iocp(Windows)实现了。

基于网络的系统调用可以异步处理，在如今我们使用的各种操作系统上。这也是网络轮询器名字的由来，因为它刚开始就是处理网络操作的。通过使用网络轮询器进行网络系统调用，调度器可以防止**G**在进行系统调用时阻塞**M**。这有助于保持**M**的可用性，用以继续执行**P**的LRQ中的其他**Gs**，而不用创建新的**M**。这有助于操作系统较少调度负载。

查看其工作原理的最佳方法是运行示例。

#### 插图3

![](https://www.ardanlabs.com/images/goinggo/94_figure3.png)

插图3向我们展示最基本的调度图示。`G1`正在`M`上执行，另外LRQ上还有三个`G`等待在`M`上获得执行时间。网络轮询器没有做任何事情，所以是空闲的。

#### 插图4

![](https://www.ardanlabs.com/images/goinggo/94_figure4.png)

在插图4中，`G1`想要进行一个网络系统调用，所以`G1`被移动到了网络轮询器处，并且处理该异步网络系统调用。一旦`G1`移动到了网络轮询器，`M`就可以执行在LRQ中的一个可用的`G`。在这个案例中，`G2`被切换到`M`上。

#### 插图5

![](https://www.ardanlabs.com/images/goinggo/94_figure5.png)

在插图5中，通过网络轮询器完成了网络异步系统调用之后，`G1`将会被重新移动到`P`的LRQ中。一个`G1`能够被切换回`M`，该`G`负责的相关代码就可以被再次执行。这里最大的好处就是，执行一个网络系统调用，不需要额外的`M`。网络轮询器有一个操作系统的线程并且它可以高效的处理时间循环。

## 同步系统调用

当一个**G**想要进行一个无法异步化的系统调用会发生什么？在这个案例中，不能再使用网络轮询器，并且**G**产生的系统调用将会导致**M**阻塞。这很不幸，但是没有任何办法去避免这样的事情发生。不能被异步化的系统调用的一个典型的例子就是基于文件的系统调用。如果你使用CGO，可能还有其他情况，调用C函数也可能会阻塞**M**。

_注意：Windows操作系统确实能够异步化基于文件的	系统调用。从技术上讲，在Windows上运行程序时，是可以使用网络轮询器的。_

让我们来看一下同步系统调用（如文件I/O）会导致M阻塞的情况。

#### 插图6：

![](https://www.ardanlabs.com/images/goinggo/94_figure6.png)

图6再次向我们展示了基本的调度图，但是这次G1将进行同步系统调用以阻止M1。

#### 插图7：

![](https://www.ardanlabs.com/images/goinggo/94_figure7.png)

在插图7中，调度器能够识别到`G1`已经导致了`M1`的阻塞。此时，调度器将`M1`与`P`分离，同时`G1`仍然附加在`M1`上。然后调度器将使用一个新的`M2`来服务`P`。此时，`M2`可以切换LRQ中的`G2`来运行。如果在交换之前已经有存在的`M`，那么此时交换一个`M`比创建一个`M`速度更快。

#### 插图8：

![](https://www.ardanlabs.com/images/goinggo/94_figure8.png)

在插图8中，由`G1`产生的系统调用已经完成。此时，`G1`可以重新被移动到LRQ中，并且再次由`P`服务。`M1`则放置在旁边备用，以便再次发生这样的（基于文件IO的同步系统调用等等）情况。

# 工作窃取

Go调度器的另一方面就是，它也是一个工作-窃取的调度器。这样有助于在一些区域内保持有效的调度。首先，你想要的结果是**M**进入等待状态，因为一旦**M**进入等待状态，操作系统会将**M**从核心中切换出去。这就意味着直到核心将**M**切换回来之前，**P**都无法完成任何工作，即使该**P**中的**Gs**处于可运行的状态。窃取工作也有助于平衡所有的**P**上的**Gs**。从而更好地分配，并更加有效的完成工作。

让我们通过运行一个示例来解释。

#### 插图9：

![](https://www.ardanlabs.com/images/goinggo/94_figure9.png)

在插图9中，我们有一个多线程的Go程序，其中两个`P`服务了4个`Gs`，每个服务的GRQ中有一个`G`。如果其中的一个`P`中的`Gs`服务（调度）地很快，那么会发生什么？

#### 插图10：

![](https://www.ardanlabs.com/images/goinggo/94_figure10.png)

在插图10中，`P1`已没有更多的**G**来执行。但这时，`P2`的LRQ和GRQ中都有可运行的**G**。这时候`P1`就需要进行工作窃取。[窃取工作](https://golang.org/src/runtime/proc.go)的规则如下。

#### 清单2：

```go
runtime.schedule() {
    // only 1/61 of the time, check the global runnable queue for a G.
    // if not found, check the local queue.
    // if not found,
    //     try to steal from other Ps.
    //     if not, check the global runnable queue.
    //     if not found, poll network.
}
```

所以基于清单2中的这些规则，`P1`需要检查`P2`LRQ中**Gs**，并取走一半已发现的**Gs**。

#### 插图12：

![](https://www.ardanlabs.com/images/goinggo/94_figure12.png)

在插图12中，`P2`完成了它的工作，并且也需要偷一些**Gs**。首先，它尝试从`P1`的LRQ中寻找可用的**G**，但是没有任何发现。下一步，它将会从GRQ中寻找可用的**G**。这时候它发现了`G9`。

#### 插图13：

![](https://www.ardanlabs.com/images/goinggo/94_figure13.png)

在插图13中，`P2`从GRQ中偷窃到了`G9`，并且开始执行其工作。所有这些偷窃工作的好处在于它允许**Ms**保持在忙碌状态而不会空闲下来。这种工作偷窃在内部被认为是**M**的自旋。这种***自旋***有一些其他的好处，这个在[***JBD*** 的博客](https://rakyll.org/scheduler/)里有解释。
