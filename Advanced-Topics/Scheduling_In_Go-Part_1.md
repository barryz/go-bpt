> 译自：[Scheduling  In Go](https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html) :book:

# Go中的调度 - 第一部分

## 介绍

Go调度器的设计和行为是你的多线程Go程序更加高效。这要归功于Go调度器对操作系统（OS）调度程序的mechanical sympathies。但是，如果你的多线程Go程序的设计和行为上与调度器程序的工作方式上没有mechanical sympathies，那么这一切都不那么重要。了解OS和Go调度器对于如何正确设计一个多线程的软件来说非常重要。

本系列文章将重点介绍调度器在更高级别上的运行机制和语义。我将提供足够多的详细信息，以便你可以看到一些内部的工作原理，方便做出更好的工程上的决策。尽管你需要为多线程程序做出更多的工程决策，机制和语义构成了你所需的基础知识的关键部分。

## 操作系统调度器

操作系统的调度器是软件行业中非常复杂的一环。它们必须考虑到它们所运行的硬件的布局和配置。这包括但不限于存在多个处理器和核心，[CPU缓冲和NUMA](http://frankdenneman.nl/2016/07/06/introduction-2016-numa-deep-dive-series)。没有这些知识，调度器就不可能尽可能高效。最棒的是，你仍然可以开发一个良好的心理模型，来了解操作系统调度器的工作原理，而无需深入研究这些主题。

你的程序只是一系列需要依次执行的机器指令。为了实现这点，操作系统使用了线程的概念。线程的工作是辨别并顺序执行它所分配的指令集。连续执行到该线程没有指令需要执行为止。这就是为什么我将线程称为”一个执行路径”的原因。

每个你运行的程序都会创建一个进程并且每个进程会有一个给定的初始化线程。线程拥有穿件更多线程的能力。这些线程都彼此独立地运行，并且调度的决策实在线程级别进行的。而不是在进程级别。线程可以并发运行（每个线程都面向一个核心），或者并行运行（每个线程同一时间在不同核心上）。线程而且保持了自身的状态，以允许安全，本地和独立执行它们的指令。

如果存在可以执行的线程，那么OS的调度器负责确保核心不在空闲状态。它还必须制造一个假象(illusion)，即所有可以执行的线程是同时执行的。在创建这种假象的过程中，调度器需要运行优先级较高的线程。但是，低优先级的线程并不会被饿死（缺乏执行时间）。调度器还需要通过快速、明智地决策尽可能地最小化调度的延迟。

为了实现这一目标，使用了很多的算法。但幸运的是，该行业有着数十年的工作和经验可以利用。为了更好地理解所有的这些，我们最好描述和定义一些重要的概念。

## 执行指令

[程序计数器(PC)](https://en.wikipedia.org/wiki/Program_counter)，有时候也被称作指令指针(IP)，被用来允许线程可以追踪下一条要执行的指令。在大多数的核心中，PC指向下一条执行而不是当前的指令。

### 插图1

![](https://www.ardanlabs.com/images/goinggo/92_figure1.jpeg)

[https://www.slideshare.net/JohnCutajar/assembly-language-8086-intermediate](https://www.slideshare.net/JohnCutajar/assembly-language-8086-intermediate)

如果你曾经看过Go程序的堆栈追踪，你可能已经注意到每行末尾的这些小十六进制数字。在清单1中查找`+0x39`和`+0x72`。

### 清单1

```bash
goroutine 1 [running]:
   main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)
       stack_trace/example1/example1.go:13 +0x39                 <- LOOK HERE
   main.main()
       stack_trace/example1/example1.go:8 +0x72                  <- LOOK HERE
```

这些数字表示从相应函数的顶部到当前偏移的PC值。`+0x39`PC偏移量表示了在`example`函数内线程将要执行的下一条指令，如果该程序没有发生恐慌的情况下。`+0x72`PC偏移量则表示了在`main`函数内线程将要执行的下一条指令，如果控制权回到`main`函数的情况下。更为重要的，该指针之前的指令会告诉你正在执行的指令。

请观察清单2的程序，该程序导致了清单1中的堆栈追踪。

```bash
https://github.com/ardanlabs/gotraining/blob/master/topics/go/profiling/stack_trace/example1/example1.go

07 func main() {
08     example(make([]string, 2, 4), "hello", 10)
09 }

12 func example(slice []string, str string, i int) {
13    panic("Want stack trace")
14 }
```
十六进制数`+0x39`表示`example`函数内的指令的PC偏移量，该指令比函数的起始指令低了57（基数10）个字节。在下面的列表3中，你可以从`example`函数的二进制中查看`objdump`信息。找到第12条指令，在底部显示的。表明了该指令上方的代码行是对`panic`的调用。

### 清单3

```bash
$ go tool objdump -S -s "main.example" ./example1
TEXT main.example(SB) stack_trace/example1/example1.go
func example(slice []string, str string, i int) {
  0x104dfa0		65488b0c2530000000	MOVQ GS:0x30, CX
  0x104dfa9		483b6110		CMPQ 0x10(CX), SP
  0x104dfad		762c			JBE 0x104dfdb
  0x104dfaf		4883ec18		SUBQ $0x18, SP
  0x104dfb3		48896c2410		MOVQ BP, 0x10(SP)
  0x104dfb8		488d6c2410		LEAQ 0x10(SP), BP
	panic("Want stack trace")
  0x104dfbd		488d059ca20000	LEAQ runtime.types+41504(SB), AX
  0x104dfc4		48890424		MOVQ AX, 0(SP)
  0x104dfc8		488d05a1870200	LEAQ main.statictmp_0(SB), AX
  0x104dfcf		4889442408		MOVQ AX, 0x8(SP)
  0x104dfd4		e8c735fdff		CALL runtime.gopanic(SB)
  0x104dfd9		0f0b			UD2              <--- LOOK HERE PC(+0x39)
```

记住，PC就是下一条指令，不是当前的指令。列表3是基于amd64的指令的一个非常好的例子，该Go程序的线程负责顺序执行。

## 线程状态

另一个重要的概念是线程状态，它决定了调度器使用线程的角色。一个线程可以是这三种状态之一： 等待中，可运行或执行中。

__等待中__：这意味着线程已经停止并且在等待某些东西才能继续。这可能是出于等待硬件（磁盘，网络），才做系统（系统调用）或同步调用（原子，互斥）等原因。这些类型的[延迟](https://en.wikipedia.org/wiki/Latency_(engineering))可能是程序性能不佳的根本原因。

__可运行__： 这意味着线程在某个核心上需要一定的时间片，以便它可以执行分配给它的指令。如果你有大量的线程需要时间片，那么线程必须等待更长的时间才能获得时间片。此外，随着更多的线程争用时间片，那么将会缩短任何给定线程获得的单独的时间片。这种类型的调度延迟也可能是程序性能不佳的根本原因。

__执行中__：这意味着线程已经在一个核心内，并且已经开始执行它的机器指令。与应用程序相关的工作即将完成。这个每个人都希望看到的。

## 工作类型

一个线程可以做两种类型的工作。第一种被称为CPU密集型，第二种被称为IO密集型。

__CPU密集型__：这类工作永远不会创建可能处于等待状态的线程。这类工作仅是需要不断的进行计算的工作。计算第N位的Pi值的线程就是CPU密集型的。

__IO密集型__： 这类工作将会导致线程进入等待状态。这类工作包括通过访问网络来请求资源或进行系统调用。一个访问数据库的线程是IO密集型的。我将在别的地方介绍包括同步事件（互斥，原子）。

## 上下文切换

如果你的程序运行在Linux，Mac或Windows上，那事实上你是在具有抢占式调度器的OS上运行的。这意味一些非常重要的事情。首先，这意味着调度器在任何给定的时间选择运行哪个线程是不可预测的。线程优先级与事件一起（（如在网络上接收数据）使得无法确定调度器将选择执行什么操作以及何时执行操作。

再者，这意味着你必须永远不要根据已有经验去编写代码，它并不能保证每次都成功。如果在应用程序中需要一些确定性。则必须控制线程的同步和编排。

在核心上交换线程的物理行为我们称之为上下文切换。当调度器从核心拿到正在执行的线程并用可运行的线程替换它时，就会发生上下文切换。从运行队列中选择的线程进入了执行状态。被取出的线程可以返回到可运行状态（如果它仍然具有运行能力的话），或者进入等待状态（如果是由于IO密集型的请求而被替换的话）。

上下文切换被认为是昂贵的，因为在核心上交换线程需要花费很多的时间。因为上下文切换而发生的延迟取决于不同的因素，但它在大约50-100纳秒之间的延迟并非不合理。考虑到硬件能够合理地执行（平均情况下）每个核心[每纳秒12条指令](https://www.youtube.com/watch?v=jEG4Qyo_4Bc&feature=youtu.be&t=266)，一次上下文切换可能需要大约600到1200个延迟的指令。本质上来说，你的程序在上下文切换期间失去了执行大量指令的能力。

如果你的应用程序是CPU密集型的工作，那么上下文切换将会成为一个噩梦。由于线程总是有工作要做，所以上下文切换是试图停止这样的工作。这种情况与IO密集型的工作负载形成了鲜明的对比。

## 少即是多

在处理器只有一个核心的年代，调度不是十分复杂。因为你只有一个单核处理器，所以在任何给定的时间内只能执行一个线程。我们的想法是定义一个调度器周期，并尝试在该段时间内执行所有可运行的线程。没问题：采用调度周期并除以需要执行的线程数。

作为一个例子，如果你将你的调度器周期定义为10毫秒并且你有两个线程，那么每个线程将会得到5毫秒的执行时间。如果你有5个线程，每个线程只能得到2毫秒的执行时间。但是，当你有100线程时会发生什么？为每个线程提供10us（微秒）的时间片不起任何作用，因为你将在上下文切换中花费大量的时间。

你需要的是限制时间片如何尽可能的短。在最后一个场景中，如果最小时间片是2毫秒并且你有100个线程，那么调度器周期则需要增加到2000毫秒（2秒）。假如有1000个线程，那么现在你的调度器周期就需要增加到20秒。如果每个线程都使用它全部的时间片，那么在这个简单的实例中，所有线程运行一次需要20秒。

请注意，这是一个非常简单的世界观。在制定[调度决策](https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/)时，调度器需要考虑和处理更多的事情。你在你的应用程序内控制你的线程数量。当有更多的线程需要考虑，并且有IO密集型工作正在发生时，会有更多混乱和不确定的行为。一些事情就需要更多的时间来调度和执行。

这就是为什么游戏规则是“少即是多”。少量的可运行状态的线程意味着较少的调度开销以及每个线程获得更长的执行时间。大量的可运行状态的线程则意味着每个线程只拥有较少的运行时间。这也就意味着你的工作也会随着时间的推移越来越久。

## 找到平衡

你需要在核心数量和获得应用程序最佳吞吐量所需的线程数之间找到平衡。在管理这种平衡时，线程池是一个很好的答案。我将在本文的第二部分向你展示Go不再需要这种方式。我认为这是Go为简化多线程应用程序开发所有的一件非常好的事情。

在使用Go编程之前，我在NT上使用过C#和C++。在那样的操作系统上，使用IOCP（IO完成端口）线程池对于编写多线程软件至关重要。作为工程师，你需要确定所需的线程池数量和任何给定的线程池的最大线程数，来最大化利用给定的核心数量和最大化程序的吞吐量。

当编写需要和数据库交互的web服务时，每核心3个线程这样的魔数总能在NT上得到最好的吞吐量。换句话说，每核心3个线程最大限度地减少了上下文切换的开销，同时最大化核心上的执行时间。当创建要给IOCP线程池时，我知道在主机上识别出每个核心上至少有1个线程，至多有3个线程。

如果我将每核心设置成两个线程，那么完成工作则需要更长的时间，因为有空闲的时间没有被利用，它可以用来完成工作。如果我将每个核心设置成4个线程。同样的，完成工作也需要更长的时间，因为上下文切换导致的延迟。每核心3个线程的平衡，无论出于何种原因，似乎在NT上，永远是一个魔数。

如果你的服务正在进行着大量不同类型的工作，那么该怎么办？这可能产生一些不一致的延迟。也许它也会创建大量需要处理的不同系统级别的事件。你可能无法找到一直适用于所有不同工作负载的魔数。当使用线程池来调整服务的性能时，找到正确的一致的配置会变得非常负载。

## 缓存行

从主内存访问数据有很高的延迟开销（大约100到300个时钟周期），处理器和核心具有本地高速缓存以使数据保持接近需要它的硬件线程。从高速缓存中访问数据的成本要低得多（大约3到40个时钟周期），具体时钟周期取决于所访问的高速缓存。今天，性能的一个方面时关于如何有效地将数据导入到处理器以减少这些数据的访问延迟。编写能够改变状态的多线程应用程序需要考虑缓存系统的机制。

### 插图2

![](https://www.ardanlabs.com/images/goinggo/92_figure2.png)

处理和主内存之间的数据交换使用[缓存行](https://www.youtube.com/watch?v=WDIkqP4JbkE)。高速缓存行的在主内存和高速缓存系统之间交换的64字节内存卡。每个核心都有自己需要的任何缓存行的副本，这意味着硬件使用[值语义](https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html)。这就是为什么多线程应用程序在内存中突变会造成性能噩梦的原因。

当并行运行的多个线程访问相同的数据值或者甚至是彼此相邻的数据值时，他们将访问同一缓存行上的数据。在任何核心上运行的任何线程都将获得自己的同一缓存行的副本。

### 插图3

![](https://www.ardanlabs.com/images/goinggo/92_figure3.png)

如果给定核心上的一个线程对其缓存副本进行了更改，然后通过硬件的魔力，同一缓存行的所有其他副本必须标记为脏数据。当一个线程尝试访问或写入一个脏的缓存行时，需要通过主内存的访问（大约100到300个时钟周期）来获得一个新的缓存行的副本。

也许在2核处理器上这不是什么大问题，但是在并行运行32个线程的32核处理器在同一个缓存行上访问和改变数据呢？具有两个物理处理器，每个处理有16个核心的又会怎么样？由于处理器到处理器通信延迟的增加，情况会变得很糟糕。该应用程序的性能会变得非常糟糕，而且很大可能，你无法理解到底发生了什么。

这被称为[缓存一致性问题](https://youtu.be/WDIkqP4JbkE)，并且还引入了诸如错误共享之类的问题。在编写将改变共享状态的多线程应用程序时，必须要考虑到缓存系统的问题。

## 调度决策的场景

想象一下，我已经要求你根据我给你的高级别信息编写OS调度器。想想你必须考虑的这种情况。请记住，这是调度器在做出调度决策时必须考虑的许多有趣的事情之一。

您启动应用程序，创建主线程，并在核心1上执行。当线程开始执行其指令时，需要开始检索缓存行，因为需要加载数据。线程现在决定为某些并发处理创建一个新的线程。这是个问题。

一旦线程常见完成并准备就绪，那么调度器应该：

1. Context-switch the main Thread off of core 1? Doing this could help performance, as the chances that this new Thread needs the same data that is already cached is pretty good. But the main Thread does not get its full time slice.

2. Have the Thread wait for core 1 to become available pending the completion of the main Thread’s time slice? The Thread is not running but latency on fetching data will be eliminated once it starts.

3. Have the Thread wait for the next available core? This would mean cache lines for the selected core would be flushed, retrieved, and duplicated, causing latency. However, the Thread would start more quickly and the main Thread could finish its time slice.

很有趣，不是吗？这些是OS调度器在做出调度决策时需要考虑的有趣的问题。幸运的时，我不是哪个制作它们（调度器决策）的人。我可以告诉你的时，如果有空闲的核心，它将会被使用。线程会在他们可以运行的时候运行起来。

## 结论

这篇文章的第一部分提供了一些你在编写多线程应用程序时对线程和OS调度器必须要考虑的内容的见解。这些也时Go调度器所需要考虑的事情，在下一篇文章中，我将描述Go调度器的语义以及它们是如何与这些信息所关联的。
