> 译自: [Value Parts](https://go101.org/article/value-part.html)

# Go 值部分（Value Parts)

之后的文章将会介绍更多种类的Go类型。 想要更加简单和深入地了解之后的文章， 我们最好在阅读这些文章之前阅读这篇文章的内容。简单来说，我们应该知道Go类型的两种分类。

## Go类型的两种分类

Go是一门类C语言，这可以通过Go中的结构体和指针来确认。 结构体类型和指针类型在Go和C中很相似。 C类型的主要特征是它们的值在内存中的布局是透明的。 内存中的每个C语言的值都占用一个连续的内存段。在下面的文章中， 我们将这种**连续的内存段**被称为**值部分**。

另一方面， Go也可以被视为C语言框架。 这主要体现在Go支持的几种类型， 其值在内存中的布局不是完全透明的。 这些类型的每个值通常由一个**直接部分**和一个（多个）**底层间接部分**组成， 而底层值部分是由直接值部分引用的。下面的图描绘了一个多值部分的情况。

![](https://go101.org/article/res/value-parts.png)

到目前为止， 除了字符串类型之外， 之前文章中引入的所有其他类型都是和C语言类型类似的。这些类型包括布尔类型， 数字类型， 结构体类型和指针类型。 另外两个类C的类型是数组类型和 `unsafe-pointer` 类型。 下一篇文章将会介绍Go数组类型， 之后的文章[unsafe](https://go101.org/article/unsafe.html)将会介绍 `unsafe-pointer` 类型。每个类C类型的值都只是由一个直接值部分组成的。

上段中没有列举到的其他类型可能包含**底层值**部分。具体来说，这些类型包括：

- slice 类型
- map 类型
- channel 类型
- function 类型
- interface 类型
- string 类型

这些类型通过封装了许多的内部实现使得Go编程变得异常便捷。不同的Go编译器可以针对这些类型采用不同的内部实现。但这些类型的值的外部行为必须满足Go规范中的要求。这些类型会在之后的文章中详细说明。

第二分类中的类型不是Go语言中的基本类型， 我们可以使用第一分类中的类型从头开始实现它们。但是，这种实现会非常冗长， 有时甚至会很无趣。 通过封装一些常见的或独特的功能并支持这些类型作为Go中的一等公民，Go语言编程的经历会变得愉快且富有成效。

另一方面， 第二分类中的类型实现的这些封装隐藏了这些类型许多的内部定义。这可以防止Go程序员查看这些类型的整个视图， 有时候这会帮助程序员更好地理解Go。

为了帮助`Gophers`更好地理解第二分类中地类型和它们的值， 本文以下的内容将会介绍这些类型的内部结构和定义。这里将不会解释这些类型的具体实现细节。 本文中的解释基于标准的Go编译器使用的实现， 但不完全相同。

## Go中的两种指针类型

在说明第二分类中各类型的内部结构定义之前， 我们先开始阐明指针和引用的关系。

之前我们学习过[指针](https://go101.org/article/pointer.html)相关的内容。 指针类型在之前文章中的介绍是类型安全的指针。 实际上， Go也支持类型不安全的指针。 标准库`unsafe`包中的`unsafe.Pointer` 提供了类似C语言中 `*void`的操作。 底层类型为`unsafe.Pointer`的在Go101系列教程里被称为不安全的指针类型。

在Go101其他的文章中， 如果没有特别指明， 当提到指针类型时， 指的就是安全的指针类型。 但是，在本文之后的部分， 当指针类型被提及时， 就有可能是安全的或不安全的指针类型。

一个指针的值存储了另一个值的地址， 除非指针值为nil指针。 我们可以说该指针值引用了另一个值， 或者另一个值被指针值所引用。 值同样可以被间接引用。

- 如果一个结构体值 `a` 的字段 `b` 引用了值 `c` ，那么我们可以认为结构体值 `a` 间接引用了值 `c`。

- 如果一个值 `x` 引用（直接或者间接）了值 `y`， 且值 `y` 直接或者间接引用了值 `z`，  那么我们可以说值 `x`间接引用了值 `z`。

具有指针类型的字段的结构体类型被称为**指针封装类型**。 一个拥有**指针封装类型**的字段的结构体类型同样也被称为**指针封装类型**。

## 第二分类中其他类型的内部定义

### Map Channel Function 类型的内部定义

map， channel， function类型的内部定义很相似：

```go
// map types
type _map *hashtableImpl // currently, for the standard Go compiler,
                         // Go maps are hashtables actually.

// channel types
type _channel *channelImpl

// function types
type _function *functionImpl
```

因此，从内部来看，这三种类型都只是指针类型。 这些类型的零值都是由预先声明的nil标识符表示。 这些类型中对于任何非零值来说， 它们的直接部分（指针）引用了它们的间接底层实现部分。

实际上， 这三种类型的间接底层部分的值也可能引用更深层次的间接底层部分。 但这篇文章将会忽略这些内容。

### Slice类型的内部定义

Slice切片类型的内部定义如下：

```go
// slice types
type _slice struct {
	elements unsafe.Pointer // underlying elements
	len      int            // number of elements
	cap      int            // capacity
}
```

从内部来看， 切片类型是一个**指针封装类型**。切片类型的零值同样是nil。每个非零切片值都具有一个间接的底层部分， 其存储了切片值得元素值。直接部分的字段 `elements` 引用了切片值得间接底层部分。

### String类型的内部定义

字符串类型的内部定义：

```go
// string types
type _string struct {
	elements *byte // underlying bytes
	len      int   // number of bytes
}
```

从内部来看， 字符串类型也是一个**指针封装类型**。字符串类型的零值是空字符串。使用 **""** 或 **``** 字面量表示。 每个字符串的值都有一个间接的底层部分， 用于存储字符串值的字节， 间接部分由该字符串值的 `elements` 字段引用。

### Interface类型的内部定义

接口类型的内部定义如下：

```go
// general interface types
type _interface struct {
	dynamicType  *_type         // the dynamic type
	dynamicValue unsafe.Pointer // the dynamic value
}
```

从内部来看， 接口类型也是一个**指针封装类型**。接口类型的内部定义中有两个指针字段。 接口类型的零值同样是nil。每个非零接口值有两个间接底层部分， 其存储了该接口值得动态类型和动态值。这两个间接部分同样是引用了接口值中的 `dynamicType` 和 `dynamicValue` 字段。

实际上，对于标准的Go编译器而言，上面的内部定义只用于空接口。 空接口类型是不需要指定任何方法的接口类型。我们可以在文章[interfaces in Go](https://go101.org/article/interface.html)了解到更多关于接口的知识。 对于一个非空接口类型，其内部定义类似下面的例子：

```go
// general interface types
type _interface struct {
	dynamicTypeInfo *struct {
		dynamicType *_type       // the dynamic type
		methods     []*_function // implemented methods
	}
	dynamicValue unsafe.Pointer // the dynamic value
}
```

接口值中的字段 `dynamicTypeInfo` 里的 `methods` 字段存储了接口值动态类型的实现方法列表。

Go运行时将会为每个接口类型和动态类型对创建最多一个**动态类型的信息结构体**， 并将该结构体值存储到全局区域。对于标准的Go运行时而言， 这个**动态类型的信息结构体**一旦创建了， 就不会被垃圾回收。 所有的 `_type` 值也会存储在全局区域。 换言之， `_type` 值和**动态类型信息结构体**值会被多个接口值共享， 他们不属于任何指定的接口值。 基于这个原因， 本文将只会集中查看接口值中的 `dynamicValue` 字段。

## 底层值部分不会在值分配操作中拷贝

目前为止，我们已经学习了第二分类中其他类型的内部定义。它们的内部定义皆为指针类型或结构体类型。当然， Go编译器绝不会将第二分类中的类型视为用户程序中的指针类型和结构体类型。 这些类型仅仅应用于Go运行时内部。

在Go中， 如果涉及分配的目标和源值都具有相同的类型（如果它们的类型不同， 我们可以认为在执行该赋值之前， 源值将会被隐式转换成目标值得类型）在每次值分配的时候都是浅复制。换言之， 在值分配中只有源值的直接部分会被拷贝到目标值中。如果一个源值有底层间接部分， 则目标值和源值得直接部分将会引用相同的底层值部分。换言之， 目标值和底层值将会共享同一个底层值部分。

![](https://go101.org/article/res/value-parts-copy.png)

实际上， 上面的理论并不是100%正确， 对于接口类型和字符串类型。[Official Go FAQ](https://golang.org/doc/faq#pass_by_value)则表示一个接口值的底层动态值部分在接口值发生拷贝时同样也会被拷贝。然而， 但是由于接口值的动态值是只读的， 因此标准的Go编译器/运行时在接口值拷贝过程中不会复制接口值中的底层动态部分。这种情形可以视为编译器优化。在字符串值得复制过程中同样也有这些优化。刨去这些优化措施， 上述理论说明对于任何类型来说又是100%正确的。

因为间接的底层部分可能不属于任何值， 所以不会影响到 `unsafe.Sizeof` 函数返回的值大小。

上面提到过， Go中的map值内部是一个哈希表。当一个接口或者字符串作为map的键时， 该接口或者字符串底层部分将会在hash计算时被计数。当一个channel被用作map的键时， 它的底层部分不会在hash计算时被计数。 Slice， Map 和 Function 不能作为map的键。

## 关于术语 “类型引用” 和 “值引用”

**引用**一词在Go世界中是非常混乱的。它在go社区带来了很多的讨论和疑惑。一些文章中， 包括一些[官方文档](https://golang.org/doc/faq#references)， 使用**引用**作为类型和值的限定符。或将**引用**看作是**值**的对立面。在Go101中强烈不建议这么做。 下面将列出一些关于**引用**绝对错误的说法：

- 只有Slice，map， channel 和function类型在Go才是引用类型。（如果我们确实需要Go中的**引用**类型术语， 那么我们不应该从引用类型中排除任何自定义指针和指针封装类型）。

- 引用和值是对立的。（如果我们确实需要Go中的**引用**类型术语， 那么我们应该讲引用值视为一个特殊的值，而不是将引用和值对立起来）。

- 一些参数通过引用传递。 （Sorry， 所有参数通过拷贝传递 :smile）。

在这里， 我并不是说Go中的引用类型和引用值术语完全没用，我只是觉得它们不是很重要。如果我们确实需要这些术语，我更喜欢将它们定义成指针或者指针封装。 然而， 我个人认为最好将**引用**一词限制为仅仅表示关系，而不是将其用作限定词。 这将避免在学习、使用Go时产生许多的混淆。
