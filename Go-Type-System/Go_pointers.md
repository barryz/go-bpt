> 译自：[Go Pointers](https://go101.org/article/pointer.html)

# Go指针

Go吸收了其他语言的各种特性，但还是被视作为类C语言。 其中一项就是指针支持。 Go指针和C指针在很多方面都很类似， 但也有一些不同的地方。 这篇文章将会剖析Go指针相关的概念和原理。

## 内存地址

内存地址表示由操作系统管理的整个内存的起始点的偏移量（字节数）。

通常来说， 内存地址存储为无符号整型字（word）。 本地字（word）在32位平台上为4个字节， 在64位的平台上为8个字节。 因此理论上最大的内存空间为2^32个字节， 在32位的平台上为4GB（1GB == 2^30字节），在64位平台上为 2^32GB。

内存地址通常用16进制表示， 比如 `0x1234CDEF`。

## 值的地址

值的地址表示由值的[直接部分direct part](https://go101.org/article/type-system-overview.html#value-part)所占有的内存段的起始地址。

[值部分value parts](https://go101.org/article/value-part.html)文章将会介绍哪些类型可能拥有间接的底层类型的值。

## 什么是指针

指针是一个用来存储内存地址的特殊值。 事实上， 我们经常称内存地址为指针， 反之亦然。

通常，存储在指针中的内存地址是另一个值的地址。 不同于C语言， 由于安全因素的考虑， Go指针有一些限制。 下面将会详述这些限制。

## Go指针的类型和值

和C语言的指针一样， 一个未命名的指针类型可以表示为 `*T`， 其中 `T` 可以是任意类型。 类型 `T` 被称为指针类型 `*T` 的基本类型。

我们也可以声明命名指针类型， 但是通常来说不推荐这么做。 未命名的指针类型在可阅读性方面优于命名指针类型。

如果一个已经定义过的指针的[底层类型](https://go101.org/article/type-system-overview.html#underlying-type) 是 `*T`。 则定义的指针类型的基类型是 `T` 。两个具有相同基类型的未定义指针类型是相同的。

例子：

```go
*int  // 未命名的指针类型的基类型是 int
**int // 多层未命名的指针类型的基类型是 *int

type Ptr *int // 命名的指针类型的基类型是 int
type PP *Ptr  // 基类型是 Ptr
```

任何指针类型的零值都是 `nil`， 没有地址存储在nil指针里。

基类型为 `T` 的指针类型的指针值可以被称为 `T` 指针。 位于非零(non-nil)指针处的值将始终被编译器视为类型 `T` 的值。

## 如何获取指针值？ 什么是可寻址的值

有两种方式可以获取到非零指针的值：

1. 内建函数 `new` 可以为任意类型分配内存。 `new(T)` 可以为`T`值分配内存并且返回`T`值的地址。分配的值是类型`T`的零值。 返回的地址的是类型`*T`的指针值。

2. 也可以用另外一种方式在Go中获取值的地址。可以取到地址的值被称为可寻址的值。 对于一个可寻址的类型`T`的`t`值来说， 我们可以使用表达式`&t`来获取`t`的地址， `&`操作符是取址符。 &t的类型是`*T`。


Go中所有的变量都是可寻址的， 所有的常量都是不可寻址的。 Go中并不是所有存储在内存中的值在运行时都可以寻址。我们可以在之后的文章中学习到其他可寻址和不可寻址的值。 可以通过文章[summary](https://go101.org/article/summaries.html#not-addressable)获取Go中可寻址和不可寻址的值的列表。


尽管可寻址的值可以被修改， 但它们的地址在整个值的生命周期中是不可变的。

## 指针的解引用（逆向引用，取指针的值）

给定一类型为`Tp`的指针值`p`， 如何获取到存储在指针中的地址对应的值？使用表达式`*p`就可取到该值，`*` 被称为逆向引用操作符。 `*p` 被称为指针`p`的逆向引用。 指针逆向引用是取址的反操作。`*p` 的结果是`Tp`基类型的值。

`nil`指针的逆向引用会导致运行时panic。

下面的程序例子展示了一些地址的获取和指针逆向引用的示例：

```go
package main

import "fmt"

func main() {
	p0 := new(int)   // p0 指向了 int的零值
	fmt.Println(p0)  // 是一个十六进制的数值
	fmt.Println(*p0) // 0

  // x 是一个存储在p0中的地址的值的拷贝
	x := *p0
	p1, p2 := &x, &x      // 都拥有x的地址
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
	p3 := &*p0            // <=> p3 := &(*p0)
	fmt.Println(p0 == p3) // true
	*p0, *p1 = 123, 789
	fmt.Println(*p2, x, *p3) // 789 789 123

	fmt.Printf("%T, %T \n", *p0, x) // int, int
	fmt.Printf("%T, %T \n", p0, p1) // *int, *int
}
```

下面的图描述了上面例子中各个值之间的关系。

![](https://go101.org/article/res/pointer.png)


## 关于“引用（Reference）” 这个词

在Go101系列教程里， 引用这个词表示了一种关系。 例如， 一个指针值存储了另外一个值的地址， 那么我们可以说这个指针值（直接）引用了另外一个值， 且另一个值至少有一个引用。 Go101教程中的引用一词的使用和Go规范一致。

## 为什么我们需要指针

我们先看下面这个例子：

```go
package main

import "fmt"

func double(a int) {
	a += a
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}
```

上面例子中的`double`函数的功能是修改入参值并返回该值x2的结果。 然而结果并不如期待那样。 为什么? 因为所有的赋值操作（包括函数的参数传递）在Go中都是值复制。 `double`函数修改的是入参的拷贝版本。 修改拷贝的值并不会影响到原先的值。

要使上述示例能够返回正确结果， 解决办法就是让该函数返回返回修改后的值。 但此方案并不能适用于所有的场景。 下面的例子演示另外一种解决方案， 使用一个指针参数。

```go
package main

import "fmt"

func double(a *int) {
	*a += *a
	a = nil // This line is just for education purpose.
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}
```
我们可以发现， 把入参变成指针类型之后， 传递的指针参数和它的拷贝引用都是一样的， 所以对局部变量`a`这个引用值的修改， 可以从函数`double`中反射出来。

一言以蔽之， 指针提供了访问某些值的间接方法， 从而可以避免复制这些值。许多其他的程序语言都没有指针概念， 但是， 指针只是隐藏在这些语言的其他概念里面。

## 返回局部变量的指针在Go是是安全的

不同于C语言， Go是一门支持垃圾回收的语言， 所以返回局部变量的指针是绝对安全的。

```go
func newInt() *int {
  a := 3
  return &a
}
```

## Go指针的限制

出于一些安全的原因， Go设置了一些限制以保证指针总是合法和安全的。通过应用这些限制， Go保留了指针的好处， 同时也避免了指针滥用导致的危险性。

### 指针值不支持算术运算

在Go里面， 指针不支持算术运算。 比如： 对于一个指针值`p`， 语句`p++`在Go里面就是非法的。如果`p`是一个数字值的指针， 那么`*v++`在Go编译器里将会被翻译成`(*v)++`。

例子：

```go
package main

import "fmt"

func main() {
	a := int64(5)
	p := &a

	// The following two lines don't compile.
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true
}
```

### 指针值无法转换成任意指针类型

在Go里面，只有在满足以下两个条件之一时， 指针类型`T1`的指针值才能直接转换成另一个指针类型`T2`。

1. 类型`T1` `T2` 的底层类型是相同的（这里可以忽略结构体标签），特别是如果`T1`和`T2`是未命名的类型，且它们的底层类型是相同的（考虑结构体标签）， 那么可以进行隐式转换。

2. 类型`T1`和`T2`同样都是未命名的指针类型，且它们的基类型的底层类型是相同的。

例子：

```go
type MyInt int64
type Ta    *int64
type Tb    *MyInt
```

上述的四种指针类型：

1. 类型`*int64`的值可以隐式地转换成类型`Ta`，反之亦然， 因为它们底层类型都是`*int64`。

2. 类型`*MyInt`的值可以隐式地转换成类型`Tb`， 反之亦然， 因为它们底层类型都是`*MyInt`。

3. 类型`*MyInt`的值可以显式地转换成类型`Tb`， 反之亦然， 因为它们基类型的底层类型都是`int64`， 且它们都是未命名的。

4. 类型`Ta`的值不能直接转换成类型`Tb`， 隐式转换也不行。 但是通过上述的三条规则， 可以通过嵌套的三次显式转换： `Tb((*MyInt)((*int64)(pa)))`， 可以将`Ta`类型的值`pa`间接转换成类型`Tb`。

任何安全的方法都不可能将上述四个指针转换成`*uint64`。


### 指针类型不能与任意类型指针的值进行比较

在Go里， 指针可以使用操作符`==` 和 `!=`进行比较。 两个指针值如果能够互相比较， 必须满足下列三个条件之一：

1. 两个指针类型是相同的。

2. 一个指针值可以隐式地转换成另一个指针。换言之， 互相比较的两种类型的底层类型必须相同， 并且两个指针类型中的任何一个都必须是未命名的指针类型。

3. 两个指针中有且仅有一个使用nil标识符表示的。


例子：

```go
package main

func main() {
	type MyInt int64
	type Ta    *int64
	type Tb    *MyInt

	// 4 nil pointers of different types.
	var pa0 Ta
	var pa1 *int64
	var pb0 Tb
	var pb1 *MyInt

	// The following 6 lines compile okay.
	// The comparison results are all true.
	_ = pa0 == pa1
	_ = pb0 == pb1
	_ = pa0 == nil
	_ = pa1 == nil
	_ = pb0 == nil
	_ = pb1 == nil

	// None of the following 3 lines compile.
	/*
	_ = pa0 == pb0
	_ = pa1 == pb1
	_ = pa0 == Tb(nil)
	*/
}
```

### 指针值不能分配作为其他指针类型的指针值

将指针值分配给另一个指针值的条件与将指针值与另一个指针值进行比较的条件是相同的。


### 如何打破Go指针的相关限制

`unsafe.Pointer` 类型提供了一些方式用来打破Go中对指针的限制。 `unsafe.Pointer`类型类似于C语言中的`void*`。 然而， 一般来说，并不建议在Go编程中使用不安全的方法。
