> 译自[Go channels](https://go101.org/article/channel.html).

# Go中的通道

通道是Go中一个非常重要的内建特性。它是使Go特别的众多特性之一。和另一个独特的功能，goroutine，这两个特性使得在Go中并发编程变得非常方便和有趣。而且这两个特性降低了并发编程的难度。

这篇文章将会列举一些关于通道的一些概念，语法和规则。想要更好地理解通道，我们还简单地描述了通道的内部结构和标准Go编译器/运行时的一些实现细节。

对于新的gophers而言，本文的一些内容可能比较晦涩。有些内容可能需要反复阅读多次才能消化。

## 并发编程和并发同步

现代CPU往往支持多喝，并且一些CPU核心也支持超线程。换句话说，现代CPU可以同时处理多条指令流水线（pipeline）。想要完全使用到多核CPU的性能，我们需要在编写程序是使用并发。

并发计算是在重叠的时间周期内进行多次计算。下面的图片描绘了两个并发计算的场景。在图中，A和B代表了两个单独的计算。第二个例子也被称作是并行计算，其是一种特殊的并发计算。在第一个例子中，A和B只有在很小的时间片内才可能并行。

![](https://go101.org/article/res/concurrent-vs-parallel.png)

并发计算可以在程序、计算机或者网络中发生。在Go101教程里，我们只讨论编程范畴的并发计算。[Gorotines](https://go101.org/article/control-flows-more.html)，正如前面介绍的，是Go支持的一种提供并发计算的方式。

并发计算可能会共享某些资源，通常是内存资源。在并发计算期间可能会发生某些情况。

- 在某次计算的同一周期内，将数据写入到内存段时，另一个计算从这个内存段中读取数据。所以，另一个计算读取到数据可能不具有完整性、正确性。

- 在某次计算的同一周期内，将数据写入到内存段时，另一个计算也将数据写入到这个内存段。所以，另一个计算写入的数据可能不具有完整性、正确性。

这两种情形被称为数据竞争。并发编程的一个职责就是控制资源在多个并发计算之间共享，这样数据竞争就不会发生。实现此任务的方法我们称之为并发同步，或数据同步。Go支持多种数据同步技术。下面的文章将会介绍到其中的一种，通道。

并发编程的其他任务包括：

- 确定需要多少计算。

- 确定一个计算的起始终止时间。

- 确定如何在多个并发计算中分摊负载。

Go中大多数的操作是非同步的，换句话说，它们不是线程安全的。这些操作包括值分配，参数传递和容器类型的元素操作，等等。Go中只有少数的操作是同步的，包括下文要引入的通道操作。

在Go里，通常来说，每个计算都是一个goroutine。所以后面我们将使用goroutine来代替计算这个术语。

## 通道介绍

来自于*Rob Pike*关于并发编程的一个建议就是**不要让goroutine通过共享内存通信，而是让它们通过通道通信来共享内存**。通道机制就是这种哲学的体现结果。

通过共享内存通信和通过通信来共享内存是并发编程的两种模式。当goroutine通过共享内存来通信时，我们需要用到一些传统的并发同步技术，例如互斥锁，用来保护共享资源从而防止数据竞争。

Go提供了一种独一无二的并发同步技术，通道。通道使得goroutines可以通过通信来共享内存。我们可以把通道看作是一个程序内的一个**FIFO**队列。一些goroutines往这个队列（通道）发送值，另外一些goroutines从这个队列接收值。

除了通过通道传递值，一些值的所有权也可以通过通道在goroutines之间传递。当一个goroutine向一个通道发送一些值，我们可以将其看作是goroutine释放了某些值得所有权。当一个goroutine从一个通道接收一些值，我们可将其看作是goroutine获取了某些值得所有权。值(其所有权被转移)通常是被转移的值的引用(但不需要被引用)。


当然，也可能没有任何所有权通过通道通信被转移。

需要注意的是，这里，当我们讨论所有权的时候，我们所指的是逻辑概念上的所有权。不同于`Rust`语言的所有权，Go并不在语法层面支持值所有权。Go通道可以帮助程序员轻松地写出无数据竞争的代码，但是也不能预防程序员写出糟糕的并发代码。

尽管Go支持传统的数据同步技术。但只有通道是Go中的**一等公民**。通道是Go中的一个类型，所以我们可以直接使用通道而无需导入任何包。另一方面，标准库`sync`和`sync/atomic`包将提供[一些传统的并发同步技术](https://go101.org/article/concurrent-synchronization-overview.html)。

老实说，每种并发同步技术都有其自身的应用场景。但是通道的[应用范围更广、使用范围也更广](https://go101.org/article/channel-use-cases.html)。通道的一个问题是，使用通道编程的体验是如此的愉快和有趣，以至于程序员在某些不是通道最佳使用场景下仍然使用通道。


## 通道类型和值

通道类型是一个综合（组合）类型。和数组、切片和map一样，每个通道类型都有一个元素类型。所有发送到通道的数据都必须是该通道元素类型的值。

通道类型可以是双向的，也可以是单向的，假设`T`是一个任意类型，

- `chan T`表示的是一个双向通道类型。编译器允许双向通道既接收值，又可以发送值。

- `chan<- T`表示的是一个发送通道类型，编译器不允许在发送通道类型上接收值。

- `<-chan T`表示的是一个接收通道类型，编译器不允许在接收通道类型上发送值。

`T`被称作是这些通道类型的元素类型。

双向通道`chan T`的值可以被转换成发送通道`chan<- T`和接收通道`<-chan T`的值。但是反之不亦然。发送通道`chan<- T`的值也不能转换成接收通道`<-chan T`的值，反之亦然。请注意，通道类型字面值中的`<-`是修饰符。

每个通道有一个容量，这个将在下一节解释。一个零容量的通道我们称之为无缓冲通道，非零容量的通道我们称之为缓冲通道。

通道类型的零值使用预先声明的标识符`nil`表示。一个非零的通道值必须通过内建函数`make`函数来创建。例如，`make(chan int, 10)`将会创建一个类型为`int`容量为0的通道。第二个参数（容量）是可选的，默认值是0。

## 通道的分配和比较

所有的通道类型都是可比较的类型。

通过文章[值部分](https://go101.org/article/value-part.html)，我们知道非零通道类型是一个**多部分值**。当将一个通道值分配给另一个通道时，这两个通道共享相同的底层部分。换句话说，这两个通道代表了相同的内部通道对象。比较它们的结果将是`true`。

## 通道操作

我们可以在一个通道上执行五种操作。假设通道是`ch`，下面将列出这些操作的语法和函数调用。

  1. 使用以下函数调用关闭通道

  ```go
  close(ch)
  ```

  这里的`close`是一个内建函数。`close`函数的参数必须是一个通道值，且通道值不能是一个只接收类型的通道。

  2. 发送一个值`v`，使用下列语法

  ```go
  ch <- v
  ```

  这里的`v`必须是可赋值给通道`ch`元素类型的值。这里要注意的是符号`<-`是通道发送符号。

  3. 从通道中接收一个值，使用下列语法

  ```go
  <- ch
  ```

  一个通道接收操作总是至少返回一个结果，这个结果就是通道元素类型的一个值。注意这里的符号`<-`是一个通道接收符号。（它的表示与通道发送操作符相同。）

  在大多数场景中，一个通道接收操作可以被视为一个单值表达式。然而，当通道操作用作赋值中唯一的源值表达式时，它却可以被视为一个多值表达式且会产生另一个可选的无类型的布尔值。（第二个结果是bool值），这个布尔值表示在通道关闭之前是否发送了第一个结果。（下面我们将了解到我们可以从一个关闭的通道中接收无限个值。） 例如，

  ```go
  v = <-ch
  v, sentBeforeClosed = <-ch
  ```

  4. 查询一个缓冲通道的容量，可以使用下列函数调用

  ```go
  cap(ch)
  ```

  在之前的文章[containers in Go]()中，我们已经介绍过内建函数`cap`。`cap`函数的返回值是一个`int`类型。

  5. 查询通道的值缓冲区（或长度）中的当前值的个数，使用下列函数调用

  ```go
  len(ch)
  ```

  `len`内建函数我们之前也介绍过。`len`函数的返回值是一个`int`类型。 上述列子返回的结果是当前被查询的通道已经被成功发送且还未被接收的值的个数。


上述所有的操作都是同步的，因此执行这些操作不需要进一步的同步。然而，和Go中其他大多数操作一样，通道的值分配并不是同步的。类似地，虽然任何通道接收操作是同步的，但是将接收的值分配给另一个值也是不同步的。

如果被查询的通道是一个nil通道，内建函数`cap`和`len`都会返回0。事实上，这两个查询操作非常简单，所以我们以后不再进一步解释。其实，这两种操作在实践中很少使用。

下面的章节将会解释通道发送，接收和关闭操作相关的规则。

## 通道操作的简单汇总

为了使通道操作规则的解释简单明了，在下文中，通道将会被分为三类：

  1. `nil`通道。
  2. 非`nil`但是已关闭的通道。
  3.  非`nil`且未关闭的通道。


下面的表格简单地描述了应用在`nil`，非`nil`，已关闭和未关闭通道上所有种类的操作的相关规则。下节中将会详细解释更多的细节。

|操作|`nil`通道|已关闭通道|未关闭非`nil`通道|
|-----|-----|------|------|
|关闭|panic|panic|成功关闭 (C)|
|发送值|永久阻塞|panic|阻塞或成功发送 (B)|
|接收值|永久阻塞|永不阻塞(D)|阻塞或成功接收 (A)|


对于上述表格中五个未标记的案例，规则非常明确。

  - 关闭一个已经关闭的或`nil`通道将会导致当前goroutine panic。

  - 向一个已经关闭的或`nil`通道发送值也将会导致当前goroutine panic。

  - 向一个`nil`通道发送值或接收值将会导致当前的goroutine进入永久阻塞状态。

下面我们将会解释上述表格中四种已经标记的案列。

 为了更好地理解通道类型和值，使得一些解释更加容易理解，了解通道内部对象的大致内部结构会非常有帮助。我们可以认为每个通道在内部都维护了三个队列：

  1. 接收goroutines队列。这个队列是没有大小限制的链表。此队列中的goroutines被称为此通道上的阻塞接收goroutine。

  2. 发送goroutines队列。这个队列也是一个没有大小限制的链表。此队列中的goroutines被称为此通道上的阻塞发送goroutine。这些goroutines试图发送的值的地址也与每个goroutine一起存储在这个队列里。

  3. 值缓冲队列。这是一个环形队列。它的大小等于通道的容量大小。如果存储在通道的值缓冲队列中的当前值的数量达到通道的容量上限，则这个通道被称为满（full）状态。如果没有值存储在通道的值缓冲队列里，则这个通道被称为空（empty）状态。对一个0容量的通道来说，它总是满足满状态和空状态。


[*通道规则A*]：当一个goroutine尝试从一个未关闭或非`nil`通道中接收值时，这个goroutine首先会尝试获取跟这个通道相关的锁，然后执行以下步骤，知道满足一个条件。

  1.
